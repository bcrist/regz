# Fork Information
The main difference between this fork and the official regz repo is the
addition of being able to specify a type overrides file.  This allows
using custom types for specific registers or fields of registers.

The code to define these custom types is not generated by regz, and there
is no checking done by regz to ensure that the layout of the custom type
matches what regz would have generated.

In addition to allowing type overrides, there are a few minor stylistic
changes in the code generated by this version of regz, but it should be
functionally identical if overrides are not used.

## Command Line
The type overrides are specified in an S-Expression file.  The path to
this file is provided with the `-x` option:

    regz -x <path-to-sx> <path-to-svd> > my-chip.zig


## Example

    (register-types.zig
        (ADC
            (ADC_ISR adc.ISR)
            (ADC_IER
                (ADRDYIE adc./%/.$)
            )
        )
        (USART*
            (* usart.%)
        )
    )

## File Format Details

The top-level expression's first string value is the file/import name to add
to the generated registers.zig file.  The names of all the custom types should
be provided in this file.

Inside this expression can be any number of peripheral expressions.  The first
value of a peripheral expression is the name of a peripheral that will be
generated by regz.  If the peripheral name ends with `*`, it will be applied
to any peripheral that matches the (optional) prefix specified prior to the
asterisk.  Note this isn't as flexible as globbing or regular expressions;
it only works when used as the last character of the name.

Inside of a peripheral expression can be any number of register expressions.
The first value in a register expression is the register name.  Similarly to
peripherals, the name may end with `*` to match any register with a common
prefix.

A register expression may contain a second string after the name, which 
indicates a struct to use for access to that register.  If the type name
contains `%`, it will be replaced with the register name.  If it contains
`@`, it will be replaced with the peripheral name.  These can be useful
when matching multiple registers/peripherals with `*`.

Alternatively, a register expression may not have a second string, but
instead have one or more subexpressions corresponding to fields defined
by regz for that register, along with the replacement type for that field.
These subexpressions always have exactly two strings, the field name
and overridden field type.  The field name can again use `*` to match
a common prefix, and the matched field name can be inserted into the
type name with `$`, along with `%` and `@` for the register and peripheral
name, respectively.

If `/` appears in a type name, it toggles on or off lowercase mode for
`@`, `%`, and `$` replacements.  It will not affect the case of literal
letters.

# regz

regz is a Zig code generator for microcontrollers. Vendors often publish files
that have the details of special function registers, for ARM this is called a
"System View Description" (SVD), for AVR the format is called ATDF. This tool
outputs a single file for you to start interacting with the hardware:

```zig
const regs = @import("nrf52.zig").registers;

pub fn main() void {
    regs.P0.PIN_CNF[17].modify(.{
        .DIR = 1,
        .INPUT = 1,
        .PULL = 0,
        .DRIVE = 0,
        .SENSE = 0,
    });
    regs.P0.OUT.modify(.{ .PIN17 = 1 });
}
```

NOTE: just including that file is not enough to run code on a microcontroller,
this is a fairly low-level tool and it is intended that the generated code be
used with something like [microzig](https://github.com/ZigEmbeddedGroup/microzig).

One can get SVD files from your vendor, or another good place is
[posborne/cmsis-svd](https://github.com/posborne/cmsis-svd/tree/master/data),
it's a python based SVD parser and they have a large number of files available.

For ATDF you need to unzip the appropriate atpack from the
[registry](https://packs.download.microchip.com).

## Building

regz targets zig master.

```
git clone https://github.com/ZigEmbeddedGroup/regz.git
cd regz
zig build
```

## Using regz to generate code

Files provided may be either SVD or ATDF.

Provide path on command line:
```
regz <path-to-svd> > my-chip.zig
```

Provide schema via stdin, must specify the schema type:
```
cat my-file.svd | regz --schema svd > my-chip.zig
```

### Does this work for RISC-V?

It seems that manufacturers are using SVD to represent registers on their
RISC-V based products despite it being an ARM standard. At best regz will
generate the register definitions without an interrupt table (for now), if you
run into problems issues will be warmly welcomed!

### What about MSP430?

TI does have another type of XML-based register schema, it is also
unimplemented but planned for support.

### Okay but I want [some other architecture/format]

The main idea is to target what LLVM can target, however Zig's C backend in
underway so it's likely more exotic architectures could be reached in the
future. If you know of any others we should look into, please make an issue!

## Roadmap

- SVD: mostly implemented and usable for mosts MCUs, but a few finishing touches in order to suss out any bugs:
    - [x] nested clusters
    - [ ] order generated exactly as defined in schema
    - [ ] finalize derivation of different components
    - [ ] comprehensive suite of tests
    - [ ] RISC-V interrupt table generation
- [x] ATDF: AVR's register schema format
- [ ] insert name of Texus Insturment's register schema format for MSP430

